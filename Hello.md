# привет

## Команда git config

### 1. Проверка наличия установленного Git

В терминале выполнить команду `git --version`

Флаги `Config filе location` - с их помощью можно простраивать и просматривать различные конфигурации различных уровней доступа в системе.

**Опция --system**

`/etc/gitconfig`  - все опции из этого файла распространяются на всех пользователей вашей операционной системы, для всех акаунтов ней

**Опция --global**

`~/.gitconfig или ~/.config/git/config` - будут располагаться в файле gitconfig, который находится в вашей рабочей директории (рабочая директория обозначена тильдой)

**Опция --local**

``.git.config`` - опции будут распространяться для конкретного git репозитория, с ее помощью для каждого git репозитория можно установить свои собственные опции.

*Команда `git config --list --show-origin` показывает все настройки, которые сейчас заданы для git*

**Установить имя и email**

`git config --global user.name "Mansurovna"`

`git config --global user.email mansurovna198@gmail.com`

**Установить отличный от стандартного редактор**

`git config --global core.editjr/emacs*`

`*git add . ` *- команда для подготовки фиксации изменений или добавление в индекс*

`*git rm --cached <file>..." to unstage` *- команда позволяет извлечь из индекса ранее добавленную информацию*

`*git commit -m` *- фиксация изменений, с коментарием, в котором указываем внесенные изменения*

### 2. Установка Git

Загружаем последнюю версию Cit c [сайта](https://git-scm.com/downloads).
Устанавливаем с настройками по умолчанию.

`git add + git commit` - это команда `git commit -a -m "текст комментария"` она добавляет все изменения, которые есть репозитории.

`git add -u` добавляет к фиксации только изменения, новые файлы не добавляет.

`git log` показывает всю исторю фиксаций

`git log --oneline` показывает сокращенный лог, только комментарии

`git checkout` позволяет нам переключаться как между удаленными, так и меду локальными ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы. Однако тут надо помнить, что пока вы не закомитили изменения, вы не сможете переключиться на другую ветку. В такой ситуации нужно либо сделать коммит, либо отложить его, при помощи команды git stash, добавляющей текущие незакоммиченные изменения в стек изменений и сбрасывающей рабочую копию до HEAD'а репозитория.

`git checkout master` переключится в папку мастер

Рабочее состояние репозитория - это когда ветка HEAD указывает на последний коммит.

`git switch` это команда возвращает нас в актуальное состояние (есть в последних версиях)

### 3. Настройка Git

При поервом запуске необходимо представиться

```git config --global user.name "My Name"```

```git config --global user.email myEmail@example.com```

### 4. Инициализация репозитория

Инициализация или создание репозитория производится командой `git init` в директории проекта, при этом директория как может содержать файлы проекта, так и может быть пустой.

По умолчанию git создаёт ветку master, где будут размещаться коммиты. В gitHUB же дефолтная ветка называется main — несоответствие веток может привести к проблемам в будущем, лучше сразу переименовать ветку master в main.

Задать имя дефолтной ветки можно с помощью команды:
```
git config --global init.defaultBranch main
```
, где main — название ветки. Эта команда работает до создания первого коммита.

Переименовать уже существующую ветку можно командой:

```
git branch -m [название ветки]
``` 

### 5. Запись изменений в репозиторий

каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). Отслеживаемые файлы — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту. Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.

Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек и вы ничего пока не редактировали.

Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, так как вы изменили их с момента последнего коммита. Вы индексируете эти изменения, затем фиксируете все проиндексированные изменения, а затем цикл повторяется.

Какие файлы в каком состоянии находятся для этого используем команду `git status`

 Статус Untracked означает, что Git видит файл, которого не было в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. 

Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда `git add`

Вы можете видеть, что файл проиндексирован, так как он находится в секции «Changes to be committed». Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды git add, будет добавлена в историю снимков состояния.

«Changes not staged for commit» — это означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду git add. 

Git также имеет флаг вывода сокращённого статуса, что позволяет их увидеть в более компактном виде: `git status -s` или `git status --short` 

### 6. Просмотр истории коммитов

После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, можно посмотреть что было сделано — историю коммитов с помощью `git log`

По умолчанию (без аргументов) git log перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. Из примера можно увидеть, что данная команда перечисляет коммиты с их SHA-1 контрольными суммами, именем и электронной почтой автора, датой создания и сообщением коммита.

Команда git log имеет очень большое количество опций для поиска коммитов по разным критериям. Рассмотрим наиболее популярные из них:

* `-p` или `--patch` - показывает разницу (выводит патч), внесённую в каждый коммит
* `--stat` - показывает сокращённую статистику для каждого коммита
* `--pretty`  - меняет формат вывода
* `oneline` - выводит каждый коммит в одну строку
* `format` - позволяет указать формат для вывода информации. Особенно это может быть полезным когда вы хотите сгенерировать вывод для автоматического анализа — так как вы указываете формат явно, он не будет изменен даже после обновления Git.
* `--graph` - отображает ASCII граф с ветвлениями и историей слияний
* `--relative-date` - отображает дату в относительном формате (например, «2 weeks ago») вместо стандартного формата даты
* `--abbrev-commit` - показывает только несколько символов SHA-1 чек-суммы вместо всех 40
* `--name-status` - показывает список файлов, которые добавлены/изменены/удалены
* `--name-only` - показывает список изменённых файлов после информации о коммите
* `git log --pretty=format` -  отображает наиболее полезные опции для изменения формата 

### 7. Перемещение между сохранениями (коммитами)

Для переключения на нужный коммит используется действие checkout. После переключения, все файлы в проекте станут такими, какими они были в данном коммите:
```
git checkout commit

```
Переключение на интересующий пользователя коммит всегда будет приводить репозитарий в состояние detached HEAD. Это нормально, не стоит этого бояться.

Нахождение в состоянии "detached HEAD" можно проверить командой git status. Состояние "detached HEAD" означает, что текущий рабочий указатель не находится ни на какой ветке, поскольку цепочки коммитов в Git не считаются ветками.

Чтобы перейти к предыдущему коммиту, нужно использовать команду git checkout с хеш-идентификатором коммита. Хеш-идентификаторы коммитов можно получить с помощью команды git log. Для перехода к предыдущему коммиту используйте следующую команду:
```
git checkout HEAD^
```
В этом случае символ «^» означает «предыдущий коммит». Если нужно перейти к коммиту, который находится на два шага назад, можно использовать команду:
```
git checkout HEAD^^
```
Чтобы перенести коммит с одной ветки на другую, нужно создать новую ветку и сделать коммит на этой ветке. Это можно сделать используя команду git checkout:
```
git checkout -b new_branch
```
Эта команда создаст новую ветку new_branch и переключится на нее. Теперь вы можете сделать коммит на этой ветке с помощью команды git commit:
```
git add <файлы>
git commit -m «имя-коммита»
```
Чтобы получить изменения из другой ветки, нужно выполнить команду git merge. Например, чтобы объединить изменения из ветки input в ветку main, нужно выполнить следующие команды:
```
git checkout main
git merge --no-ff input -m «Сообщение о слиянии веток»
```
Ключ «--no-ff» указывает Git создать новый коммит, даже если был произведен fast-forward merge. Аргумент «-m» используется для указания сообщения о слиянии.

### 8. Игнорирование файлов
Для того, чтобы исключить из отслеживания в репозитории определенные файлы или папки необходимо создать там файл ***gitignore*** и записать в него их названия или по шаблону, или соответвующие таким файлам или папкам.

К шаблонам в файле .gitignore применяются следующие правила:

Пустые строки, а также строки, начинающиеся с #, игнорируются.

Стандартные шаблоны являются глобальными и применяются рекурсивно для всего дерева каталогов.

Чтобы избежать рекурсии используйте символ слеш (/) в начале шаблона.

Чтобы исключить каталог добавьте слеш (/) в конец шаблона.

Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.

Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами. Символ (*) соответствует 0 или более символам; последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (?) соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом ([0-9]), соответствуют любому символу из интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы указать на вложенные каталоги: a/**/z соответствует a/z, a/b/z, a/b/c/z, и так далее.

### 9. Создание веток в Git
По умолчанию имя основной ветки в Git - **master** (main)

Создать ветку можно командой:
```
git branch <имя новой ветки>
```
Список веток в репозитории можно посомтреть с помощью команды `git branch`

Текущая папка будет отмечена звездочкой **\* master

Эта команда создает и сразу переключает на новую ветку:
```
git checkout -b new
```
Если пользователю нужно получить список определенного множества веток, то тогда можно воспользоваться ключами. Одними из самых распространенных будут:

-r — при использовании этого ключа мы получим список удаленных веток,
-a — используя этот параметр, в выводе будут удаленные и локальные ветки.

### 10. Слияние и разрешение конфликтов

Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить, он выдаст сообщение о конфликте слияния CONFLICT (content) - это значит, что Git не создал коммит слияния автоматически. Он остановил процесс до тех пор, пока вы не разрешите конфликт.

Всё, где есть неразрешённые конфликты слияния, перечисляется как неслитое. 

Если это вас устраивает и вы убедились, что все файлы, где были конфликты, добавлены в индекс — выполните команду git commit для создания коммита слияния.

### 11. Удаление веток

Git не позволит вам удалить ветку, над которой вы в данный момент работаете. Поэтому вы должны убедиться, что выполнили проверку на ветку, которую вы НЕ удаляете. Для этого используйте команду git checkout `<branch-name>`

Чтобы удалить тестовую ветку локально, мы используем команду :
```
git branch -d <branch-name>
```
Опция -d удалит ветку, только если она уже была удалена и объединена с удаленной веткой. Если вы хотите принудительно удалить ветку, вам придется вместо этого использовать опцию -D . Флаг -D является синонимом –delete –force. Это принудительно удалит ветку, даже если она не была удалена или объединена с удаленным. полная команда:
```
git branch -D <branch-name>
```
Вы не можете использовать команду git branch для удаления удаленной ветки. Вместо этого вы должны использовать команду git push с флагом –delete, за которой следует название ветки, которую мы хотим удалить. Вам также необходимо указать удаленное имя (в данном случае origin) после “git push”. Команда выглядит следующим образом:
```
git push <remote-name> --delete <branch-name>
```
Вы также можете использовать сокращение:
```
git push <remote-name> :<branch-name>
```
## Работа с удаленными репозиториями

1. Создать аккаунт на GitHub
2. Создать локальный репозиторий
3. Создать удаленный репозиторий
4. Связать удаенный репозиторий с локальным

Добавить удаленный репозиторий к проекту:
```
git remote add <имя для репозитория> <url-адрес репозитория в сети>
```
```c#
while (count < 0)
{
count++
}
```
Для получения и слияния изменений из удаленного репозитория используется команда:
```
git pull
```
Отправить изменения локального репозитория в удаленный
```
git push
```
Список удалённых репозиториев `git remote`


# Работа с удаленными репозиториями

1. Создать аккаунт на GitHub
2. Создать локальный репозиторий
3. Создать удаленный репозиторий
4. Связать удаенный репозиторий с локальным

Добавить удаленный репозиторий к проекту:
```
git remote add <имя для репозитория> <url-адрес репозитория в сети>
```
```c#
while (count < 0)
{
count++
}
```
Для получения и слияния изменений из удаленного репозитория используется команда:
```
git pull
```
Отправить изменения локального репозитория в удаленный
```
git push
```
Список удалённых репозиториев `git remote`